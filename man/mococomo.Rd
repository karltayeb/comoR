% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mococomo.R
\name{mococomo}
\alias{mococomo}
\title{Implements covariate moderated ASH "MOre COmponents COvariate MOderated"}
\usage{
mococomo(
  betahat,
  se,
  X,
  Z,
  mnreg_type = "mult_reg",
  max_class = 20,
  scales = NULL,
  nullweight = 0.1,
  tol = 0.001,
  max_iter = 100
)
}
\arguments{
\item{betahat}{the estimated coefficient}

\item{se, }{the  corresponding standard error (set to 1 if not provided)}

\item{X}{covariate of interest}

\item{Z}{additional covariate for adjustement}

\item{mnreg_type}{character that specify the type of regression method used for
latent states default 'mult_reg'}

\item{max_class}{maximum number of class}

\item{scales}{vector of positive value to define the prior variance manually.
If not specified otherwise done following the ash procedure}

\item{nullweight}{penalty for the null component}

\item{tol}{stopping criterion}

\item{max_iter}{maximum number of iteration}
}
\description{
Implements covariate moderated ASH "MOre COmponents COvariate MOderated"
}
\details{
Function implementation the mococomo mode
}
\examples{
effect_var <- 3


N=5000
x1 <- rnorm(N,sd=3)
beta0=-2
beta1=1
samp_prob <- 1/(1 +exp(-(beta0+beta1*x1)))
P=20
mix <- c()
betahat <- c()
betatrue <- c()

X <- cbind( x1, matrix(rnorm(P*N), ncol=P))

se <-   rchisq(N, df=1 )
#se <- rep(1,N)
for ( i in 1:N){
 mix <-c(mix, sample(c(0,1), size=1, prob = c(1- samp_prob[i], samp_prob[i])))
 betatrue <- c(betatrue,  mix[i] *rnorm(1,sd=effect_var))
 betahat <- c( betahat ,   betatrue[i]+rnorm(1,sd=se[i] ) )
}

#p <- runif(N)
X <- cbind( x1, matrix(rnorm(P*N), ncol=P))
plot( x1,betahat, col=mix+1)
plot( x1,betatrue)

fit <- mococomo(betahat=betahat, se=se ,X=X,max_iter=5, nullweight = 0.1)
df1 <- data.frame( betahat =betahat,
                  x =x1, col=fit$post_assignment[,1])
P1 <- ggplot(df1 , aes( y=betahat ,x =x1, col=fit$post_assignment[,1]))+
           geom_point()+
           ggtitle(("Posterior assignment for\n null comp  mococomo"))

res_ash <- ash(betahat , se)
df3 <- data.frame( betahat =betahat,
                  x =x1, col=res_ash$result$lfdr)
P3 <- ggplot(df3 , aes( y=betahat ,x =x , col=col))+geom_point()+ggtitle(("Posterior assignment for\n null comp ash"))
library(gridExtra)
grid.arrange(P1,P3,ncol=2)
plot(  betahat,fit$result$mean)
abline(a=0,b=1)
points(betahat,res_ash$result$PosteriorMean, col="green")
plot(  betatrue, fit$result$mean)
abline(a=0,b=1)
points(betahat,res_ash$result$PosteriorMean, col="green")
#Lower RMSE for mococomo
sqrt(sum( (fit$result$mean  -betatrue )^2))
sqrt(sum( (res_ash$result$PosteriorMean-betatrue )^2))
}
